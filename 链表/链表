动态数组有个明显的缺点：
    存储空间是连续的，扩容长度*1.5倍。导致存储空间的浪费。可以使用链表修正这种缺点。内存地址不一定是连续的，逻辑上连续的。
    快慢指针，fast = head.next.next,slow = head.next 如果有环，一定会相遇。
    加个头。虚拟头结点。这样可以考虑的情况更少一些。
    如果没有头结点，那么第一个节点只有next，没有头，而从第二个节点开始，既有next，也有pre，所以要讲头结点单独处理。
    为了代码简洁。最好可以加个头结点。return的时候，返回newHead.next
    newNode = Node("start")



    最好  最坏  平均（所有可能的复杂度相加/所有可能的个数表达式，去除系数，常数，低阶）
增：o(1)  o(n)    o(n)    # 因为链表修改删除，要先查询定位到该节点。所以整体复杂度o(n) + 1 = o(n)
删：o(1)  o(n)    o(n)
查：o(1)  o(n)    o(n)
改：o(1)  o(n)    o(n)

动态数组：开辟销毁内存空间的次数相对较少，但可能造成内存空间浪费
双向链表：开辟销毁内存空间次数相对较多，但不会浪费空间。

如果频繁在尾部添加，删除操作，用动态数组和双向链表，list
如果频繁在头部添加，删除操作，建议使用双向链表
如果频繁在任意位置添加，删除，建议双向链表
如果频繁查询，使用动态数组，list


循环链表：
    注意第一个，需要特殊处理，其他都一样。

双向链表维护一个first和last或者head，tail
单向链表只维护一个head或者first





